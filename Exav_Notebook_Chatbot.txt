from typing import List, Dict

import boto3
import faiss
import numpy as np
from tqdm import tqdm
from botocore.exceptions import ClientError
from langchain_text_splitters import RecursiveCharacterTextSplitter

import fitz as pymupdf
from PIL import Image
import pytesseract
from langchain_aws import ChatBedrock



# -----------------------
# CONFIG
# -----------------------
BASE_DIR = "data"
CHUNK_SIZE = 2000
CHUNK_OVERLAP = 200
EMBED_DIM = 1024   # Titan v2 embedding dimension
EMBEDDING_MODEL_ID = "amazon.titan-embed-text-v2:0"
LLM_MODEL_ID = "anthropic.claude-3-haiku-20240307-v1:0"

TESSERACT_CMD = os.getenv("TESSERACT_CMD", "")
if TESSERACT_CMD:
    pytesseract.pytesseract.tesseract_cmd = TESSERACT_CMD

logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger(__name__)
warnings.filterwarnings("ignore")

SAFE_NAME_RE = re.compile(r"[^A-Za-z0-9._-]+")

def safe_name(s: str) -> str:
    return SAFE_NAME_RE.sub("-", (s or "document").strip())

def create_directories(base_dir: str):
    for d in ["text", "checkboxes", "meta"]:
        os.makedirs(os.path.join(base_dir, d), exist_ok=True)




# -----------------------
# Plan Name Extraction
# -----------------------
PLAN_PATTERNS = [
    re.compile(r"^\s*Plan\s*Name\s*[:\-]\s*(.+)$", re.I),
    re.compile(r"^\s*Name\s*of\s*Plan\s*[:\-]\s*(.+)$", re.I),
    re.compile(r"^\s*2\.?\s*Plan\b.*?Name\s*[:\-]\s*(.+)$", re.I),
]
FALLBACK_SUFFIXES = ("401(k) Plan", "Profit Sharing Plan", "Retirement Plan")

def extract_plan_name(all_text: str) -> str:
    lines = all_text.splitlines()
    head = lines[:600]
    for pat in PLAN_PATTERNS:
        for line in head:
            m = pat.search(line)
            if m:
                return m.group(1).strip().strip("-:")
    for line in head:
        if any(line.strip().endswith(s) for s in FALLBACK_SUFFIXES):
            return line.strip()
    for line in lines:
        if any(line.strip().endswith(s) for s in FALLBACK_SUFFIXES):
            return line.strip()
    return "Unknown Plan"





# -----------------------
# Checkbox Normalization
# -----------------------
def normalize_checkboxes(text: str) -> str:
    replacements = {
        r"\[\s*[|]?\s*\]": "[ ]",     # | ] , [ | , | | â†’ [ ]
        r"\[\s*X\s*[|]?\s*\]": "[X]", # [ X ], | X, etc â†’ [X]
        r"\|\s*X\s*\|?": "[X]",       # | X â†’ [X]
        r"\|\s*\|": "[ ]",            # | | â†’ [ ]
        r"â˜’": "[X]", r"â˜‘": "[X]", r"â– ": "[X]",
    }
    out = text
    for pat, repl in replacements.items():
        out = re.sub(pat, repl, out, flags=re.IGNORECASE)
    return out

def filter_checked_only(text: str) -> str:
    """Keep only [X] lines as binding elections."""
    return "\n".join(line for line in text.splitlines() if "[X]" in line)

# -----------------------
# OCR Fallback
# -----------------------
def ocr_page_to_text(page: pymupdf.Page, scale: float = 2.0) -> str:
    pix = page.get_pixmap(matrix=pymupdf.Matrix(scale, scale))
    img = Image.open(io.BytesIO(pix.tobytes("png")))
    return pytesseract.image_to_string(img)






# -----------------------
# Embeddings (batched + progress)
# -----------------------
def generate_text_embeddings_batch(texts: List[str]) -> List[List[float]]:
    client = boto3.client(service_name="bedrock-runtime")
    results = []
    with tqdm(total=len(texts), desc="Generating embeddings") as pbar:
        for t in texts:
            try:
                body = {"inputText": t}
                resp = client.invoke_model(
                    modelId=EMBEDDING_MODEL_ID,
                    body=json.dumps(body),
                    accept="application/json",
                    contentType="application/json",
                )
                result = json.loads(resp.get("body").read())
                results.append(result["embedding"])
            except ClientError as e:
                logger.error("Titan invoke failed: %s", e)
                results.append(None)
            pbar.update(1)
    print("âœ… Embedding generation complete.")
    return results






# -----------------------
# PDF Processing
# -----------------------
def process_pdf(input_path: str):
    fname = os.path.basename(input_path)
    safe_fname = safe_name(fname)
    filepath = os.path.join(BASE_DIR, safe_fname)

    if os.path.abspath(input_path) != os.path.abspath(filepath):
        shutil.copy(input_path, filepath)
    else:
        filepath = input_path

    create_directories(BASE_DIR)
    doc = pymupdf.open(filepath)
    num_pages = len(doc)
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=CHUNK_SIZE, chunk_overlap=CHUNK_OVERLAP, length_function=len
    )

    items: List[Dict] = []
    all_text_pages: List[str] = []

    for page_num in tqdm(range(num_pages), desc="Processing PDF"):
        page = doc[page_num]
        native_text = page.get_text("text") or ""
        ocr_text = ocr_page_to_text(page)
        merged_text = normalize_checkboxes((native_text + "\n" + ocr_text).strip())
        all_text_pages.append(merged_text)

        # Chunks
        for i, chunk in enumerate(text_splitter.split_text(merged_text)):
            items.append({"page": page_num, "type": "text", "text": chunk})

        # Checkboxes (checked only)
        checked_text = filter_checked_only(merged_text)
        if checked_text:
            items.append({"page": page_num, "type": "checkbox", "text": checked_text})

    # Metadata
    all_text = "\n\n".join(all_text_pages)
    meta = {
        "pdf_name": safe_fname,
        "plan_name": extract_plan_name(all_text),
        "pages": num_pages,
    }

    # Embeddings
    print(f"ðŸ”„ Generating embeddings for {len(items)} chunks...")
    texts = [it["text"] for it in items]
    embeddings = generate_text_embeddings_batch(texts)

    valid_items = []
    vecs = []
    for it, emb in zip(items, embeddings):
        if emb is not None:
            it["embedding"] = emb
            valid_items.append(it)
            vecs.append(emb)

    if not vecs:
        raise RuntimeError(" No embeddings generated")

    vecs = np.array(vecs, dtype=np.float32)
    index = faiss.IndexFlatL2(EMBED_DIM)
    index.add(vecs)
    return meta, index, valid_items







# -----------------------
# Claude Invocation
# -----------------------
def invoke_claude(question: str, matched_items: List[Dict]):
    context = "\n---\n".join([it["text"] for it in matched_items if it.get("text")])
    system_msg = [
        {
            "text": (
                "You are a domain expert in U.S. retirement plan Adoption Agreements.\n"
                "Rules:\n"
                "1. Only consider lines with [X] (checked).\n"
                "2. Ignore all [ ] unchecked options.\n"
                "3. Always preserve numeric values.\n"
                "4. Cite election/section numbers if present.\n"
                "5. Answer strictly from context.\n"
                "6. If no [X] found, answer: 'Not specified in the retrieved context.'\n"
                "7. Always respond in JSON with fields: answer, election_ref, section_ref, raw_text."
            )
        }
    ]
    msg_list = [
        {
            "role": "user",
            "content": [{"type": "text", "text": f"Context:\n{context}\n\nQuestion: {question}"}],
        }
    ]
    native_request = {
        "messages": msg_list,
        "system": system_msg,
        "anthropic_version": "bedrock-2023-05-31",
        "max_tokens": 500,
    }
    llm = ChatBedrock(model_id=LLM_MODEL_ID)
    resp = llm.invoke(json.dumps(native_request))
    return resp.content



# -----------------------
# Ask Question
# -----------------------
def ask_question(question: str, index, items, k: int = 6):
    q_emb = generate_text_embeddings_batch([question])[0]
    D, I = index.search(np.array(q_emb, dtype=np.float32).reshape(1, -1), k)
    matched = [items[i] for i in I.flatten()]
    return invoke_claude(question, matched)




input_pdf = "/home/shreyo/MCA-STR-AI/data/TEST CASE 1 V2 - Standardized_401k_Adoption_Agreement Highlighted - Redacted.pdf"
meta, index, kept_items = process_pdf(input_pdf)
print("âœ… Ingested plan:", meta["plan_name"])





questions = [
    "At what age is an employee eligible to participate in the plan?",
    "How long must an employee work to be eligible to participate in the plan?",
    "When can an employee begin contributing to the plan?",
    "Are there limits on the contributions/deferrals employee participants can make to the plan?",
    "What type of contributions may an employee make to the plan?",
    "What type of contributions will my employer make to the plan?",
    "How much are participants matched on their contributions?",
    "Does the plan have automatic deferrals?",
    "What is the automatic deferral rate?",
]

for q in questions:
    print("\nQ:", q)
    print("A:", ask_question(q, index, kept_items))









